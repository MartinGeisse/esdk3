package name.martingeisse.esdk.core.library.signal.getter;

import name.martingeisse.esdk.core.library.procedural.ProceduralBitRegister;
import name.martingeisse.esdk.core.library.procedural.ProceduralMemoryIndexSelection;
import name.martingeisse.esdk.core.library.procedural.ProceduralVectorRegister;
import name.martingeisse.esdk.core.library.signal.BitSignal;
import name.martingeisse.esdk.core.library.signal.Signal;
import name.martingeisse.esdk.core.library.signal.VectorSignal;
import name.martingeisse.esdk.core.library.signal.connector.SignalConnector;
import name.martingeisse.esdk.core.library.signal.mux.ConditionalOperation;
import name.martingeisse.esdk.core.library.signal.mux.SwitchSignal;
import name.martingeisse.esdk.core.library.signal.operation.*;
import name.martingeisse.esdk.core.library.signal.vector.Concatenation;
import name.martingeisse.esdk.core.library.signal.vector.ConstantIndexSelection;
import name.martingeisse.esdk.core.library.signal.vector.IndexSelection;
import name.martingeisse.esdk.core.library.signal.vector.RangeSelection;
import name.martingeisse.esdk.core.util.Matrix;
import name.martingeisse.esdk.core.util.vector.Vector;
import org.objectweb.asm.Label;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.List;

/**
 * Each getter that is generated by this class is only used in one place since the code is highly specialized. So there
 * is no need to define useful names for its ultimate input signals or other data sources -- we just generate fields
 * with helper names, define and instantiate the class, then assign the data sources.
 */
class GetterGenerator {

    private static final String GET_BIT_SIGNATURE = "()Z";
    private static final String GET_VECTOR_SIGNATURE = "()L" + internal(Vector.class) + ";";

    private static int CLASS_COUNTER = 0;

    static BitSignalGetter generate(BitSignal signal) {
        return (BitSignalGetter)generateInternal(BitSignalGetter.class,
                GET_BIT_SIGNATURE, signal, Opcodes.IRETURN);
    }

    static VectorSignalGetter generate(VectorSignal signal) {
        return (VectorSignalGetter)generateInternal(VectorSignalGetter.class,
                GET_VECTOR_SIGNATURE, signal, Opcodes.ARETURN);
    }

    private static String internal(Class<?> c) {
        return c.getName().replace('.', '/');
    }

    private static Object generateInternal(Class<?> superClass, String descriptor, Signal signal, int returnOpcode) {
        try {

            ClassNode classNode = new ClassNode();
            classNode.version = 52;
            classNode.name = "GeneratedSignalGetter_" + CLASS_COUNTER;
            classNode.superName = internal(superClass);
            classNode.access = Opcodes.ACC_PUBLIC;

            MethodNode constructorNode = new MethodNode();
            constructorNode.name = "<init>";
            constructorNode.desc = "()V";
            constructorNode.access = Opcodes.ACC_PUBLIC;
            constructorNode.visitCode();
            constructorNode.visitVarInsn(Opcodes.ALOAD, 0);
            constructorNode.visitMethodInsn(Opcodes.INVOKESPECIAL, internal(superClass), "<init>", "()V", false);
            constructorNode.visitInsn(Opcodes.RETURN);
            classNode.methods.add(constructorNode);

            MethodNode methodNode = new MethodNode();
            methodNode.name = "getValue";
            methodNode.desc = descriptor;
            methodNode.access = Opcodes.ACC_PUBLIC;

            GetterGenerator generator = new GetterGenerator(classNode, methodNode);
            methodNode.visitCode();
            generator.renderSignal(signal);
            methodNode.visitInsn(returnOpcode);
            classNode.methods.add(methodNode);

            CLASS_COUNTER++;
            Object instance = GeneratedClassLoader.INSTANCE.defineClass(classNode).getConstructor().newInstance();
            generator.initializeFields(instance);
            return instance;

        } catch (Exception e) {
            throw new RuntimeException("could not generate signal getter", e);
        }
    }

    private final ClassNode classNode;
    private final MethodNode methodNode;
    private final List<Object> references = new ArrayList<>();

    GetterGenerator(ClassNode classNode, MethodNode methodNode) {
        this.classNode = classNode;
        this.methodNode = methodNode;
    }

    void renderSignal(Signal signal) {

        // handle connectors
        if (signal instanceof SignalConnector) {
            renderSignal(((SignalConnector) signal).getConnected());
            return;
        }

        // handle procedural registers (avoiding the interface method call)
        if (signal instanceof ProceduralBitRegister) {
            renderReference(signal);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(ProceduralBitRegister.class),
                    "getValue", GET_BIT_SIGNATURE, false);
            return;
        }
        if (signal instanceof ProceduralVectorRegister) {
            renderReference(signal);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(ProceduralVectorRegister.class),
                    "getValue", GET_VECTOR_SIGNATURE, false);
            return;
        }

        // handle bit operations
        if (signal instanceof BitNotOperation) {
            renderSignal(((BitNotOperation) signal).getOperand());
            renderBitSwitch(() -> methodNode.visitInsn(Opcodes.ICONST_1), () -> methodNode.visitInsn(Opcodes.ICONST_0));
            return;
        }
        if (signal instanceof BitOperation) {
            BitOperation operation = (BitOperation)signal;
            renderSignal(operation.getLeftOperand());
            switch (operation.getOperator()) {

                case AND:
                    renderBitSwitch(() -> methodNode.visitInsn(Opcodes.ICONST_0),
                            () -> renderSignal(operation.getRightOperand()));
                    break;

                case OR:
                    renderBitSwitch(() -> renderSignal(operation.getRightOperand()),
                            () -> methodNode.visitInsn(Opcodes.ICONST_1));
                    break;

                case XOR:
                    renderSignal(operation.getRightOperand());
                    renderIfTrue(this::renderNot);
                    break;

                case XNOR:
                    renderSignal(operation.getRightOperand());
                    renderIfFalse(this::renderNot);
                    break;

                default:
                    throw new RuntimeException("unknown BitOperation.Operator: " + operation.getOperator());

            }
            return;
        }

        // handle vector operations
        if (signal instanceof VectorOperation) {
            VectorOperation operation = (VectorOperation)signal;
            renderSignal(operation.getLeftOperand());
            renderSignal(operation.getRightOperand());
            String operationMethodName;
            switch (operation.getOperator()) {

                case ADD:
                    operationMethodName = "add";
                    break;

                case SUBTRACT:
                    operationMethodName = "subtract";
                    break;

                case MULTIPLY:
                    operationMethodName = "multiply";
                    break;

                case AND:
                    operationMethodName = "and";
                    break;

                case OR:
                    operationMethodName = "or";
                    break;

                case XOR:
                    operationMethodName = "xor";
                    break;

                default:
                    throw new RuntimeException("unknown VectorOperation.Operator: " + operation.getOperator());

            }
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), operationMethodName,
                    "(L" + internal(Vector.class) + ";)L" + internal(Vector.class) + ";", false);
            return;
        }
        if (signal instanceof ShiftOperation) {
            ShiftOperation shift = (ShiftOperation)signal;
            renderSignal(shift.getLeftOperand());
            renderSignal(shift.getRightOperand());
            String methodName;
            switch (shift.getDirection()) {
                case LEFT:
                    methodName = "shiftLeft";
                    break;
                case RIGHT:
                    methodName = "shiftRight";
                    break;
                default:
                    throw new RuntimeException("unknown ShiftOperation.Direction: " + shift.getDirection());
            }
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "getAsUnsignedInt",
                    "()I", false);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), methodName,
                    "(I)L" + internal(Vector.class) + ";", false);
            return;
        }

        // handle vector comparison
        if (signal instanceof VectorComparison) {
            VectorComparison comparison = (VectorComparison)signal;
            renderSignal(comparison.getLeftOperand());
            renderSignal(comparison.getRightOperand());
            VectorComparison.Operator operator = comparison.getOperator();
            if (operator == VectorComparison.Operator.EQUAL || operator == VectorComparison.Operator.NOT_EQUAL) {
                methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "equals",
                        "(Ljava/lang/Object;)Z", false);
                if (operator == VectorComparison.Operator.NOT_EQUAL) {
                    renderNot();
                }
            } else {
                methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "compareUnsigned",
                        "(L" + internal(Vector.class) + ";)I", false);
                switch (operator) {
                    case LESS_THAN:
                        renderBitSwitchToBoolean(Opcodes.IFLT);
                        break;
                    case LESS_THAN_OR_EQUAL:
                        renderBitSwitchToBoolean(Opcodes.IFLE);
                        break;
                    case GREATER_THAN:
                        renderBitSwitchToBoolean(Opcodes.IFGT);
                        break;
                    case GREATER_THAN_OR_EQUAL:
                        renderBitSwitchToBoolean(Opcodes.IFGE);
                        break;
                    default:
                        throw new RuntimeException("unknown VectorComparison.Operator: " + comparison.getOperator());
                }
            }
            return;
        }

        // handle conditional operations
        if (signal instanceof ConditionalOperation) {
            ConditionalOperation conditional = (ConditionalOperation)signal;
            renderSignal(conditional.getCondition());
            renderBitSwitch(() -> renderSignal(conditional.getOnFalse()), () -> renderSignal(conditional.getOnTrue()));
            return;
        }

        // handle concatenation
        if (signal instanceof Concatenation) {
            renderReference(Vector.of(0, 0));
            for (Signal elementSignal : ((Concatenation) signal).getSignals()) {
                renderSignal(elementSignal);
                if (elementSignal instanceof BitSignal) {
                    methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "concat",
                            "(Z)L" + internal(Vector.class) + ";", false);
                } else if (elementSignal instanceof VectorSignal) {
                    methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "concat",
                            "(L" + internal(Vector.class) + ";)L" + internal(Vector.class) + ";", false);
                } else {
                    throw new RuntimeException("invalid signal: " + elementSignal);
                }
            }
            return;
        }

        // handle switch/case signals
        if (signal instanceof SwitchSignal<?>) {
            SwitchSignal<?> switchSignal = (SwitchSignal<?>)signal;

            // labels
            Label[] caseMatchedLabels = new Label[switchSignal.getCases().size()];
            for (int i = 0; i < caseMatchedLabels.length; i++) {
                caseMatchedLabels[i] = new Label();
            }
            Label finishLabel = new Label();

            // branching
            {
                renderSignal(switchSignal.getSelector());
                int caseIndex = 0;
                for (SwitchSignal.Case<?> aCase : switchSignal.getCases()) {
                    for (Vector selectorValue : aCase.getSelectorValues()) {
                        methodNode.visitInsn(Opcodes.DUP);
                        renderReference(selectorValue);
                        methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "equals",
                                "(Ljava/lang/Object;)Z", false);
                        methodNode.visitJumpInsn(Opcodes.IFNE, caseMatchedLabels[caseIndex]);
                    }
                    caseIndex++;
                }
                methodNode.visitInsn(Opcodes.POP);
                if (switchSignal.getDefaultSignal() == null) {
                    methodNode.visitTypeInsn(Opcodes.NEW, internal(RuntimeException.class));
                    methodNode.visitInsn(Opcodes.DUP);
                    methodNode.visitMethodInsn(Opcodes.INVOKESPECIAL, internal(RuntimeException.class), "<init>",
                            "()V", false);
                    methodNode.visitInsn(Opcodes.ATHROW);
                } else {
                    renderSignal(switchSignal.getDefaultSignal());
                    methodNode.visitJumpInsn(Opcodes.GOTO, finishLabel);
                }
            }

            // results
            {
                int caseIndex = 0;
                for (SwitchSignal.Case<?> aCase : switchSignal.getCases()) {
                    methodNode.visitLabel(caseMatchedLabels[caseIndex]);
                    methodNode.visitInsn(Opcodes.POP);
                    renderSignal(aCase.getBranch());
                    methodNode.visitJumpInsn(Opcodes.GOTO, finishLabel);
                    caseIndex++;
                }
            }
            methodNode.visitLabel(finishLabel);
            return;
        }

        // selections (bit from vector, vector from vector, vector from matrix)
        if (signal instanceof ConstantIndexSelection) {
            ConstantIndexSelection selection = (ConstantIndexSelection)signal;
            renderSignal(selection.getContainerSignal());
            push(selection.getIndex());
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "select", "(I)Z", false);
            return;
        }
        if (signal instanceof IndexSelection) {
            IndexSelection selection = (IndexSelection)signal;
            renderSignal(selection.getContainerSignal());
            renderSignal(selection.getIndexSignal());
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "getAsUnsignedInt",
                    "()I", false);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "select", "(I)Z", false);
            return;
        }
        if (signal instanceof RangeSelection) {
            RangeSelection selection = (RangeSelection)signal;
            renderSignal(selection.getContainerSignal());
            push(selection.getFrom());
            push(selection.getTo());
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "select",
                    "(II)L" + internal(Vector.class) + ";", false);
            return;
        }
        if (signal instanceof ProceduralMemoryIndexSelection) {
            ProceduralMemoryIndexSelection selection = (ProceduralMemoryIndexSelection)signal;
            renderReference(selection.getMemory().getMatrix());
            renderSignal(selection.getIndexSignal());
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Vector.class), "getAsUnsignedInt",
                    "()I", false);
            methodNode.visitMethodInsn(Opcodes.INVOKEVIRTUAL, internal(Matrix.class), "getRow",
                    "(I)L" + internal(Vector.class) + ";", false);
            return;
        }

        // fallback: call .getValue()
        renderReference(signal);
        if (signal instanceof BitSignal) {
            methodNode.visitMethodInsn(Opcodes.INVOKEINTERFACE, internal(BitSignal.class),
                    "getValue", GET_BIT_SIGNATURE, true);
        } else {
            methodNode.visitMethodInsn(Opcodes.INVOKEINTERFACE, internal(VectorSignal.class),
                    "getValue", GET_VECTOR_SIGNATURE, true);
        }

    }

    void renderReference(Object reference) {
        String name = "reference" + references.size();
        String descriptor = "L" + internal(reference.getClass()) + ";";
        classNode.visitField(Opcodes.ACC_PUBLIC, name, descriptor, null, null);
        methodNode.visitVarInsn(Opcodes.ALOAD, 0);
        methodNode.visitFieldInsn(Opcodes.GETFIELD, classNode.name, name, descriptor);
        references.add(reference);
    }

    // computes the logical NOT of the top-of-stack
    void renderNot() {
        renderBitSwitch(() -> methodNode.visitInsn(Opcodes.ICONST_1), () -> methodNode.visitInsn(Opcodes.ICONST_0));
    }

    void renderBitSwitch(int branchingOpcode, Runnable falseCase, Runnable trueCase) {
        Label label1 = new Label();
        Label label2 = new Label();
        methodNode.visitJumpInsn(branchingOpcode, label1);
        falseCase.run();
        methodNode.visitJumpInsn(Opcodes.GOTO, label2);
        methodNode.visitLabel(label1);
        trueCase.run();
        methodNode.visitLabel(label2);
    }

    void renderBitSwitch(Runnable falseCase, Runnable trueCase) {
        renderBitSwitch(Opcodes.IFNE, falseCase, trueCase);
    }

    void renderBitSwitchToBoolean(int branchingOpcode) {
        renderBitSwitch(branchingOpcode, () -> methodNode.visitInsn(Opcodes.ICONST_0),
                () -> methodNode.visitInsn(Opcodes.ICONST_1));
    }

    // pops the top-of-stack and executes a piece of code if it is true
    void renderIfTrue(Runnable trueCase) {
        Label label = new Label();
        methodNode.visitJumpInsn(Opcodes.IFEQ, label);
        trueCase.run();
        methodNode.visitLabel(label);
    }

    // pops the top-of-stack and executes a piece of code if it is false
    void renderIfFalse(Runnable falseCase) {
        Label label = new Label();
        methodNode.visitJumpInsn(Opcodes.IFNE, label);
        falseCase.run();
        methodNode.visitLabel(label);
    }

    void push(int value) {
        switch (value) {

            case -1:
                methodNode.visitInsn(Opcodes.ICONST_M1);
                return;

            case 0:
                methodNode.visitInsn(Opcodes.ICONST_0);
                return;

            case 1:
                methodNode.visitInsn(Opcodes.ICONST_1);
                return;

            case 2:
                methodNode.visitInsn(Opcodes.ICONST_2);
                return;

            case 3:
                methodNode.visitInsn(Opcodes.ICONST_3);
                return;

            case 4:
                methodNode.visitInsn(Opcodes.ICONST_4);
                return;

            case 5:
                methodNode.visitInsn(Opcodes.ICONST_5);
                return;

        }
        if (value == (byte)value) {
            methodNode.visitIntInsn(Opcodes.BIPUSH, value);
            return;
        }
        if (value == (short)value) {
            methodNode.visitIntInsn(Opcodes.SIPUSH, value);
            return;
        }
        methodNode.visitLdcInsn(value);
    }

    void initializeFields(Object instance) throws Exception {
        Class<?> theClass = instance.getClass();
        for (int i = 0; i < references.size(); i++) {
            Object reference = references.get(i);
            theClass.getField("reference" + i).set(instance, reference);
        }
    }

}
